---
title: "Dynamic models and simulations"
author: "Jingmeng Cui"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Dynamic models and simulations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(simlandr)
```

# Introduction

The whole story starts with a dynamic model. 

Formally speaking, a **dynamic model** is a set of equations that specify how all the variables of a system changes over time. It usually takes the form of (stochastic) differential/difference equations. 

These dynamic models is rather abstract, so they can only be used for computation when they are implemented in a simulation function. A **simulation function** is a function that simulate how the model variables change over time. It takes some parameters as input, and returns a recording of the simulation process.

Currently, the whole package can only support the simulation function with certain format. It should takes (besides from other parameters) lists of model parameters as input, and give a matrix as the output. If your original simulation function is in another format, maybe some modification is needed.

`simlandr` package provides a simulation function for a simple toy model, which is called `sim_fun_test()`. You can use this as an example of the correct function format. I will also use this function as an example through out this vignette. It takes `par1` and `par2` as parameters: `par1` should be a list containing `var1` and `var2`, and `par2` should be a list containing `var3`. It takes this nested structure because real-life functions often have a bunch of parameters in different categories (e.g., starting values, model parameters, parameters that control the behavior of the simulation function, etc.) To avoid confusions in terms, the package refers to these first-layer parameters as *par*s, and second-layer parameters as *var*s.

```{r}
sim_fun_test
```

# Single simulation

For the author of a simulation function, running a single simulation is easy. You can just run the function normally, and assign the output to a variable. (If you are using others' simulation function, please read its documentation or ask the author about how to run it correctly.)

```{r}
single_test <- sim_fun_test(
  par1 = list(var1 = 1),
  par2 = list(var2 = 1, var3 = 0)
)
head(single_test)
```

# Out-of-memory storage of the simulation output

Sometimes the output of the simulation is so large that it cannot be handled properly in the following computation. (Rule of thumb: retain matrices of > 1 GB in memory is likely to produce future problems in a computer with 8 GB memory.) In this case, you can use the `bigmemory` package to put it into your hard drive. `bigmemory` only preserves a pointer in the memory, so it can save the memory space significantly. In most cases, you can treat it as a normal matrix. As far as I have tested, `simlandr` is fully compatible with `bigmemory`.

```{r eval = FALSE}
# NOT RUN
single_test <- bigmemory::as.big.matrix(single_test, backingfile = "single_test.bin", descriptorfile = "single_test.desc")
```

The pointer only exists in a single session. In other words, if you close the session and reload the workspace image, the pointers will become `NULL`, and `bigmemory` attachment does not restore by itself. In order to use it again, use the following command to attach the file.

```{r eval = FALSE}
# NOT RUN
single_test <- bigmemory::attach.big.matrix("single_test")
```

------

**âš  WARNING** 

Due to a bug of RStudio (https://github.com/rstudio/rstudio/issues/8923), its variable inspector cannot handle objects with null external pointers. Sometimes it results in a fatal error when loading workspace image with previous `bigmemory`-related objects.

Current work-around before the bug is fixed: 

1. Turn off "Restore .RData into workspace at startup" at Tools -> Project Options -> General
2. Switch the variable inspector to "Manual Refresh Only"
3. Load the image attach all `bigmemory`-related objects.

After that, you can safely use/refresh the variable inspector. 

------

To reuse these images on a hard drive, `big.matrix` class in `bigmemory` requires an explicit file name for each matrix. This can be cumbersome if you need to handle a lot of matrices. (And this is even a bigger problem for batch simulation; see next section.) Therefore, `simlandr` provides a `hash-big.matrix` class to solve this problem. The `hash-big.matrix` class is a modification of `big.matrix` class in `big.memory` package, but it automatically generates the file names using the md5 values of the matrices. (For those who are not familiar with md5: it is a hash algorithm that can guarantee to give different names to different matrices in a reasonable simulation context.) The md5 value is also stored in the `md5` slot of `hash-big.matrix` objects. Therefore, the file link can also be restored automatically without having to specify a file name. By default, all the backing files of `hash-big.matrix` objects are in `\bp` directory.

```{r eval = FALSE}
# NOT RUN
single_test <- as.hash_big.matrix(single_test)
single_test <- attach.hash_big.matrix(single_test)
```


# Batch simulation

Sometimes you need to simulate a set of models with different parameter values. `simlandr` provides several tools to do this easily.

First, you need to make a `var_grid` to specify the conditions of these simulations in terms of `var` values. The following is an example.

```{r}
## Step 1: create a variable set
batch_test <- new_var_set()

## Step 2: add variable and its starting, end, and increment values of the sequence (passed to `seq()`) to the set.
batch_test <- batch_test %>%
  add_var("par2", "var3", 0, 0.5, 0.1)

## Step 3: make variable grids
batch_test_grid <- make_var_grid(batch_test)

```

Then you can run the batch simulation.

```{r}

## Step 4: run the batch simulation
batch_test_result <- batch_simulation(batch_test_grid, sim_fun_test,
  default_list = list(
    par1 = list(var1 = 0),
    par2 = list(var2 = 0, var3 = 0)
  )
)
batch_test_result
batch_test_result <- attach_all_matrices(batch_test_result)

# WARNING if you are using bigmemory: Due to a bug of RStudio (https://github.com/rstudio/rstudio/issues/8923), its variable inspector cannot handle objects with null external pointers. Work around: Turn off "automatically load workspace image"; change the variable inspector to "Manual refresh only", and then load the image and use attach_all_matrices for all batch simulations. After that, you can safely use the variable inspector. #

# Batch simulation with two parameters

batch_test2 <- new_var_set()
batch_test2 <- batch_test2 %>%
  add_var("par1", "var1", -0.2, 0.2, 0.2) %>%
  add_var("par2", "var2", -0.2, 0.2, 0.2)
batch_test_grid2 <- make_var_grid(batch_test2)

batch_test_result2 <- batch_simulation(batch_test_grid2, sim_fun_test,
  bigmemory = FALSE,
  default_list = list(
    par1 = list(var1 = 0),
    par2 = list(var2 = 0, var3 = 0)
  )
)
batch_test_result2
```

